# Outputs from the discussion sessions
Catherine Jones, 7th November 2016

## Session 1: What makes software successful?

After spliting into groups, the following areas were identified ( I have grouped them)

### Interface & Design 
* User friendly and intuitive
* cool logos (design)
* Usability
* High quality documents
* Fast to use/run
* versatile
* Keyboard shortcuts - higher productivity
* simple interface
* easy to set up

*Key conclusions* Ability to use the software is an important factor of success. Visual appearance may influence the perception of success. 

### Community
* Lots of people use them (broad usage) (3)
* Positive profileration via word of mouth
* lots of plugins/user activity/active community
* Forums
* Discussion groups
* Still alive
* Still used
* still developed
* recent activity: bug fixes, updates
* new issues being generated
* community support

*Key conclusions* An active community is important and there needs to be a visible online presence for the community. Successful software is perceived as one having a wide user base. This may cause issues for software for a very niche area which will have a low potential user base

### Design principles
* Frontend libraries (boostrap, angular js, jquery)
* Web browser
* Multi-platform (3)
* Built on Open Source components
* Reliability (2)
* customisable interface

*Key conclusions* There was a view put forward that multiple platforms is a good thing. Successful software should be reliable

### Other
* High position in search engine results
* Lot of use cases
* has grown
* citations for the software
* clear licenses

*Key conclusions* Success means being able to find it and know what you can do with it once you have

## Session 2 Measures of success
In this session, groups chose three success criteria and looked at measures.  There was a comment that some of these measures depending where in the software lifecycle you were

From other comments, it is obvious that having a dedicated website helps for the discovery and reputation of the software. Perhaps it is important to have enough information to understand the context and to establih a trusted relationship?

### Popularity
* Number of downloads from main repository
* Number of other software programmes which depend on it

### Functionality
* Checklist comparision of required features
* Dependencies count
* Does it do what is is supposed to?: count issues/bugs (low is good?); categorise issues by type

### Performance
* Compare speeds across different software

### Development Activity
* Date of last update
* Frequency of updates
* Stars, patches, forks
* Public roadmap available
* Speed at which issues are resolved/closed

### Acknowledgement
* Citations in research papers

### Community
* Community is growing: number of active participants in a rolling window
* Issues generated outside the main developer/team



